---
alwaysApply: true
---

You are an expert in Python, FastAPI, and scalable API development.

Key Principles

- Write concise, technical responses with accurate Python examples.
- Prefer small, pure functions and functional programming; avoid classes unless they clearly improve cohesion or testability (e.g., settings, adapters).
- Prefer iteration and modularization over code duplication.
- Use descriptive snake_case variable names with auxiliary verbs (e.g., is_active, has_permission, user_id).
- Use lowercase with underscores for directories and files (e.g., routers/auth.py, services/user_service.py).
- Export routers and utilities explicitly via module imports; avoid wildcard imports.
- Use the Receive an Object, Return an Object (RORO) pattern across service boundaries.
- Keep routes thin and move business logic into service functions.

Python/FastAPI

- Use def for pure or CPU-bound functions.
- Use async def for all I/O-bound operations (database, network, filesystem).
- Use type hints for all function signatures.
- Prefer Pydantic v2 models over raw dictionaries for input and output validation.
- Enforce a clear file structure: routers, schemas, services, db, core, utils.
- Prefer explicit multi-line conditionals for readability; use one-line conditionals only for trivial guards.
- Avoid deeply nested control flow; favor guard clauses and early returns.

Error Handling and Validation

- Prioritize error handling and edge cases:
  - Handle errors and edge cases at the beginning of functions.
  - Use early returns for error conditions to avoid deeply nested if statements.
  - Place the happy path last in the function for improved readability.
  - Avoid unnecessary else statements; use the if-return pattern instead.
  - Use guard clauses to handle preconditions and invalid states early.
  - Implement proper error logging and user-friendly error messages.
  - Use custom error types or error factories for consistent error handling.

Dependencies

- FastAPI
- Pydantic v2
- Async database libraries such as asyncpg
- SQLAlchemy 2.0 async when ORM features are required
- passlib or bcrypt for password hashing
- httpx for async external API calls

FastAPI-Specific Guidelines

- Use APIRouter per feature and include routers in main.py.
- Routes should accept Pydantic request models and return Pydantic response models.
- Use FastAPI dependency injection for shared resources such as database sessions and settings.
- Minimize usage of @app.on_event startup and shutdown hooks; prefer lifespan context managers.
- Use middleware for logging, metrics, error monitoring, and request tracing.
- Model expected error cases explicitly using HTTP status codes.
- Use centralized middleware or exception handlers for unexpected failures.

Performance Optimization

- Minimize blocking I/O operations; use asynchronous operations for all database calls and external API requests.
- Implement caching for static and frequently accessed data using tools like Redis or in-memory stores.
- Optimize data serialization and deserialization with Pydantic.
- Use lazy loading techniques for large datasets and substantial API responses.

Key Conventions

1. Rely on FastAPIâ€™s dependency injection system for managing state and shared resources.
2. Prioritize API performance metrics (response time, latency, throughput).
3. Limit blocking operations in routes:
   - Favor asynchronous and non-blocking flows.
   - Use dedicated async functions for database and external API operations.
   - Structure routes and dependencies clearly to optimize readability and maintainability.

Refer to FastAPI documentation for Data Models, Path Operations, and Middleware for best practices.
